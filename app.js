/* app.js
 * Main program to process Apple health CSVs
 * as generated by https://github.com/freddiefujiwara/ahcd
 * 
 * Author: balain   https://github.com/balain
 * License: MIT
 */

const debug = require('debug')('app.js')
var args = require('minimist')(process.argv.slice(2))
const fs = require('fs')
const path = require('path')
const csv = require('@fast-csv/parse')
const Influx = require('influx')

const debugging = args.debug || false               // Enable extra output
const measurement = args.measurement || 'mmt'       // Influx measurement label
const host = args.host || 'localhost'               // Influx database host
const database = args.database || 'health'          // Influx database name
const dropdb = args.dropdb || false                 // Drop the database before processing data?
const immediateSave = args.immediateSave || false   // Save to Influxdb on every row (poor performance)

const errors = []                                   // Capture errors caught during processing
const dataToSave = []                               // Used for batch Influx imports
let scope = "undef"                                 // Set for each CSV file

const basePath = args._[0]                          // The folder containing the CSV files (Required)
if (!basePath) {
	console.log('Base path is a required parameter.')
	process.exit(10)
}

if (debugging) {
	console.log(`debugging: ${debugging}`)
	console.log(`host: ${host}`)
	console.log(`database: ${database}`)
	console.log(`measurement: ${measurement}`)
	console.log(`basePath: ${basePath}`)
	console.log(`dropdb: ${dropdb}`)
	console.log(`immediateSave: ${immediateSave}`)
}

// Set up the connection to the Influx database
const influx = new Influx.InfluxDB({
	host: host,
	database: database,
	schema: [{
		measurement: measurement,
		tags: [ 'source', 'sourceVersion', 'creationDate', 'device', 'unit' ],
		fields: {
			bpm: Influx.FieldType.INTEGER,
			mph: Influx.FieldType.FLOAT,
			inches: Influx.FieldType.FLOAT,
			mi: Influx.FieldType.FLOAT,
			vel: Influx.FieldType.FLOAT
		}
	}]
})

// Specify the CSV files (specified by https://github.com/freddiefujiwara/ahcd)
let HEARTRATE_FILENAME = 'HeartRate.csv'
let WALKINGSPEED_FILENAME = 'WalkingSpeed.csv'
let WALKINGSTEPLENGTH_FILENAME = 'WalkingStepLength.csv'
let DISTANCEWALKINGRUNNING_FILENAME = 'DistanceWalkingRunning.csv'

if (debugging) { // Subset of the files - must be created manually
	HEARTRATE_FILENAME = 'HeartRate-200.csv'
	WALKINGSPEED_FILENAME = 'WalkingSpeed-200.csv'
	WALKINGSTEPLENGTH_FILENAME = 'WalkingStepLength-200.csv'
	DISTANCEWALKINGRUNNING_FILENAME = "DistanceWalkingRunning-200.csv"
}

// Drop the db, if requested ** Broken
async function cleanup() {
	return new Promise((resolve, reject) => {
		// TODO: Fix this
		// if (dropdb) {
		// 	influx.dropDatabase(database)
		// 		.then(() => { console.log(`Database (${database}) dropped.`)})
		// 		.finally(() => { resolve('ok') })
		// }
	})
}

// Create the db, if missing (automatic)
async function setup() {
	return new Promise((resolve, reject) => {
		// Create the database if it doesn't already exist (from Influx docs)
		influx.getDatabaseNames()
			.then(names => {
				if (!names.includes(database)) {
					debug(`Couldn't find database ${database}, so creating it...`)
					resolve(influx.createDatabase(database))
				}
			})
	})
}

// Parse the 4 CSV files

// 1. HeartRate
const hr = new Promise((resolve, reject) => {
	const scope = "HeartRate"
	fs.createReadStream(path.resolve(basePath + HEARTRATE_FILENAME))
		.pipe(csv.parse({ headers: true }))
		.on('data', (row) => {
			// debug(`${row.endDate} == ${Date.parse(row.endDate)}\t${row.value}`)
			const record = {measurement: 'mmt', tags: { source: row.sourceName, sourceVersion: row.sourceVersion, creationDate: row.creationDate, device: null, unit: row.unit }, fields: { bpm: row.value }, timestamp: Date.parse(row.endDate)*1000000 }
			// debug(`...`, record)
			if (immediateSave) {
				influx.writePoints([record])
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err, record: record })
					})
			} else {
				dataToSave.push(record)
			}
		})
		.on('end', (rowCount) => {
			debug(`${scope}: Done reading ${rowCount} rows!`)
			if (!immediateSave) {
				influx.writePoints(dataToSave)
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err })
					})
					.finally(() => { console.log(`Done with ${scope}`)})
			}
		})
})

// 2. WalkingSpeed
const ws = new Promise((resolve, reject) => {
	const scope = "WalkingSpeed"
	fs.createReadStream(path.resolve(basePath + WALKINGSPEED_FILENAME))
		.pipe(csv.parse({ headers: true }))
		.on('data', (row) => {
			// debug(`${row.endDate} == ${Date.parse(row.endDate)}\t${row.value}`)
			const record = {measurement: 'mmt', tags: { source: row.sourceName, sourceVersion: row.sourceVersion, creationDate: row.creationDate, device: row.device, unit: row.unit }, fields: { mph: row.value }, timestamp: Date.parse(row.endDate)*1000000 }
			// debug(`...`, record)
			if (immediateSave) {
				influx.writePoints([record])
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err, record: record })
					})
			} else {
				dataToSave.push(record)
			}
		})
		.on('end', (rowCount) => {
			debug(`${scope}: Done reading ${rowCount} rows!`)
			if (!immediateSave) {
				influx.writePoints(dataToSave)
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err })
					})
					.finally(() => { console.log(`Done with ${scope}`)})
			}
		})
})

// 3. WalkingStepLength
const wsl = new Promise((resolve, reject) => {
	const scope = "WalkingStepLength"

	fs.createReadStream(path.resolve(basePath + WALKINGSTEPLENGTH_FILENAME))
		.pipe(csv.parse({ headers: true }))
		.on('data', (row) => {
			// debug(`${row.endDate} == ${Date.parse(row.endDate)}\t${row.value}`)
			const record = {measurement: 'mmt', tags: { source: row.sourceName, sourceVersion: row.sourceVersion, creationDate: row.creationDate, device: row.device, unit: row.unit }, fields: { inches: row.value }, timestamp: Date.parse(row.endDate)*1000000 }
			// debug(`...`, record)
			if (immediateSave) {
				influx.writePoints([record])
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err, record: record })
					})
			} else {
				dataToSave.push(record)
			}
		})
		.on('end', (rowCount) => {
			debug(`${scope}: Done reading ${rowCount} rows!`)
			if (!immediateSave) {
				influx.writePoints(dataToSave)
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err })
					})
					.finally(() => { console.log(`Done with ${scope}`)})
			}
		})
})

// 4. DistanceWalkingRunning
const dwr = new Promise((resolve, reject) => {
	const scope = "DistanceWalkingRunning"
	fs.createReadStream(path.resolve(basePath + DISTANCEWALKINGRUNNING_FILENAME))
		.pipe(csv.parse({ headers: true }))
		.on('data', (row) => {
			// debug(`${row.endDate} == ${Date.parse(row.endDate)}\t${row.value}`)
			// const durationSec = (Date.parse(row.endDate) - Date.parse(row.startDate)) / 10000
			// const vel = ((row.value / durationSec) > 0 ? (row.value / durationSec) : 0)
			// debug(`vel: ${vel}`)
			if (row.value <= 0.006) { // Filter out combined values
				const record = {measurement: 'mmt', tags: { source: row.sourceName, sourceVersion: row.sourceVersion, creationDate: row.creationDate, device: row.device || 'unknown', unit: row.unit }, fields: { mi: row.value, vel: 0 }, timestamp: Date.parse(row.endDate)*1000000 }
				// debug(`...`, record)
				if (immediateSave) {
					influx.writePoints([record])
						.catch(err => {
							console.log(`ERROR: `, err.message)
							errors.push({ scope: scope, error: err, record: record })
						})
				} else {
					dataToSave.push(record)
				}
			} else {
				// debug(`Removing mi value ${row.value}: Too large`)
			}
		})
		.on('end', (rowCount) => {
			debug(`${scope}: Done reading ${rowCount} rows!`)
			if (!immediateSave) {
				influx.writePoints(dataToSave)
					.catch(err => {
						console.log(`ERROR: `, err.message)
						errors.push({ scope: scope, error: err })
					})
					.finally(() => { console.log(`Done with ${scope}`)})
			}
		})
})

// Main processing flow
cleanup()
.then(() => {
	setup()
	.then(() => {
		// Execute all the promises
		Promise.all([hr, ws, wsl, dwr])
			.then((values) => {
				console.log(`values: `, values)
			})
		})
})